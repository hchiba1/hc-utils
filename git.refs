#!/usr/bin/perl -w
use strict;
use File::Basename;
use Getopt::Std;
my $PROGRAM = basename $0;
my $USAGE=
"Usage: $PROGRAM
";

my %OPT;
getopts('st', \%OPT);

my $fh;
if ($OPT{s} && $OPT{t}) {
    open($fh, "| sort -k6,7 -k8.5,8.5 | align_column") || die;
} elsif ($OPT{s}) {
    open($fh, "| sort -k6,7 -k8.5,8.5") || die;
} elsif ($OPT{t}) {
    open($fh, "| align_column") || die;
} else {
    $fh = *STDOUT;
}

my %NAME = ();
for my $index (`git ls-files --stage`) {
    chomp($index);
    my ($prefix, $file) = split("\t", $index);
    my ($permisson, $object, $num) = split(/\s+/, $prefix);
    if ($num) {
        $NAME{$object} = "$file($num)";
    } else {
        $NAME{$object} = "$file";
    }
}

my @file = (
    ".git/[A-Z]*",
    ".git/index",
    ".git/objects/*/*",
    ".git/refs/*/*",
    ".git/refs/*/*/*"
    );
my @line = `ls -lrtdF --full-time @file 2>/dev/null | sed 's/\\.[0-9]\\+ \\S\\+//'`;
chomp(@line);

my %REFS = ();
my %CHECK_REFS = ();
my %HEAD;
for my $line (@line) {
    if ($line !~ /\/$/ && $line !~ /tags/ && $line !~ /index/ && $line !~ /objects/) {
        my @f = split(/\s+/, $line);
        my $file = $f[7];
        my $contents = `cat $file`;
        chomp($contents);
        if ($contents) {
            my @content = split("\n", $contents);
            my @col = split(/\s+/, $content[0]);
            add_ref($col[0], $file);
        }
    }
}

for my $line (@line) {
    if ($line =~ /^(.+)(.git\/objects\/\w\w\/.*)$/) {
        my ($prefix, $object) = ($1, $2);
        $object =~ s|^.git/objects/||;
        $object =~ s|/||;
        my $type = get_type($object);
        print $fh "$prefix\[$type\]\t";
        print_object($fh, $object);
        print $fh "\n";
    } elsif ($line !~ /\/$/ && $line !~ /tags/ && $line !~ /objects/) {
        print $fh "$line";
        if ($line =~ /index/) {
            my $n = keys %NAME;
            print $fh "\t$n files";
        } else {
            my @f = split(/\s+/, $line);
            my $file = $f[7];
            my $contents = `cat $file`;
            chomp($contents);
            if ($contents) {
                my @content = split("\n", $contents);
                my $content = $content[0];
                if (@content == 1) {
                    $content =~ s/\t/    /g;
                    print $fh "\t$content";
                } else {
                    print $fh "\t\"$content\" ...";
                }
            }
        }
        print $fh "\n";
    }
}

if ($OPT{t} || $OPT{s}) {
    close($fh);
}

################################################################################
### Functions ##################################################################
################################################################################
sub get_type {
    my ($object) = @_;

    my $type = `git cat-file -t $object`;
    chomp($type);

    if ($type eq "blob") {
        return "file";
    } elsif ($type eq "tree") {
        return "directory";
    } elsif ($type eq "commit") {
        return "history";
    } elsif ($type eq "tag") {
        return "tag";
    } else {
        return "";
    }
}

sub add_ref {
    my ($content, $ref) = @_;

    if ($content =~ /ref: refs\/heads\/(\S+)/) {
        my $branch = $1;
        $HEAD{$branch} = 1;
    }

    $ref =~ s|\.git/refs/heads/||;
    $ref =~ s|\.git/refs/remotes/||;
    $ref =~ s|\.git/refs/remotes/||;
    $ref =~ s|\.git/||;
    if (!$CHECK_REFS{$content}{$ref}) {
        if ($REFS{$content}) {
            push @{$REFS{$content}}, $ref;
        } else {
            $REFS{$content} = [$ref];
        }
        $CHECK_REFS{$content}{$ref} = 1;
    }
}

sub print_object {
    my ($fh, $object) = @_;

    print $fh "$object";
    if ($REFS{$object}) {
        my @ref = @{$REFS{$object}};
        my $refs = join(", ", @ref);
        print $fh " ($refs)";
        for my $ref (@ref) {
            if ($HEAD{$ref}) {
                print $fh " <- HEAD";
            }
        }
    }
    if ($NAME{$object}) {
        my $name = $NAME{$object};
        print $fh " $name";
    }
}
