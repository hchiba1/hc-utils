#!/usr/bin/perl -w
use strict;
use File::Basename;
use Getopt::Std;
use File::Path;
use Digest::SHA 'sha256_hex';
use HTTP::Date;
my $PROGRAM = basename $0;
my $USAGE=
"Usage: $PROGRAM [OPTIONS] URL
get [-l] URL/ > LIST
get URL | less
get -f URL
get -o OUT_FILE URL
-v: verbose
-n: do not use cache
-u: print URL and quit
-q: print command and quit
-d: debug
-L CACHE_FILE_SIZE_LIMIT
";

my $CACHE_TIME_LIMIT = 3600; # one hour
# my $CACHE_FILE_SIZE_LIMIT = 4096; # 4KiB
my $CACHE_FILE_SIZE_LIMIT = 100000; # 4KiB
my $CACHE_DIR = "$ENV{HOME}/.get/cache";
my $TREE_DIR = "$ENV{HOME}/.get/tree";
my $BOOKMARK = "$ENV{HOME}/.get/bookmarks";
my $COMMAND = "curl --max-time 100000 -Lf";

my %OPT;
getopts('lfo:vnuqdL:', \%OPT);

if ($OPT{L}) {
    $CACHE_FILE_SIZE_LIMIT = $OPT{L};
}

!$OPT{v} and $COMMAND .= "sS";

### get URL
if (@ARGV != 1) {
    print STDERR $USAGE;
    exit 1;
}
my ($URL) = @ARGV;
$URL =~ s/^ftp:\/\///;

$URL = search_bookmark($URL);

if ($URL !~ /\//) {
    $URL .= "/";
}
if ($URL !~ /\/$/ && -d "$TREE_DIR/$URL") {
    $URL .= "/";
}

my $CACHE_FILE_PATH = get_cache_file($URL);

my $CURRENT_TIME = localtime;

### debug
if ($OPT{u}) {
    print STDERR $URL, "\n";
    exit;
}

### get directory contents
if ($URL =~ /\/$/) {
    if ($OPT{l}) {
        exec_command("$COMMAND -l $URL");
    } else {
        if ($OPT{q}) {
            print "$COMMAND $URL\n";
        } elsif ($OPT{d}) {
            system "$COMMAND $URL";
        } else {
            my $retrieved = retrieve_cache($CACHE_FILE_PATH);
            if (! $retrieved) {
                if (! -e "$TREE_DIR/$URL") {
                    mkpath("$TREE_DIR/$URL") || warn $!;
                }
                my @list = `$COMMAND $URL`;
                my $result = format_list(@list);
                print $result;
                save_cache($CACHE_FILE_PATH, $result);
            }
        }
    }
    exit;
}

### get file contents
if ($OPT{f}) {
    exec_command("$COMMAND -OR $URL");
} elsif ($OPT{o}) {
    exec_command("$COMMAND -o $OPT{o} $URL");
} else {
    if ($OPT{q}) {
        print "$COMMAND $URL\n";
    } else {
        my $retrieved = retrieve_cache($CACHE_FILE_PATH);
        if (! $retrieved) {
            my @result = `$COMMAND $URL`;
            my $result = join("", @result);
            print $result;
            my $size = length($result);
            if ($size <= $CACHE_FILE_SIZE_LIMIT) {
                save_cache($CACHE_FILE_PATH, $result);
            }
        }
    }
}

################################################################################
### Functions ##################################################################
################################################################################

sub search_bookmark {
    my ($input) = @_;

    my ($prefix, $suffix);
    if ($input =~ /^([\w\.]+)$/) {
        $prefix = "$1";
        $suffix = "";
    } elsif ($input =~ /^([\w\.]+)(\/.*)/) {
        ($prefix, $suffix) = ($1, $2);
    } else {
        return $input;
    }
    
    if (-f $BOOKMARK) {
        open(BOOKMARK, $BOOKMARK) || die $!;
        while (<BOOKMARK>) {
            if (/^$prefix\s+(\S+)/) {
                my $found = $1;
                if ($suffix) {
                    return "$found$suffix";
                } else {
                    return "$found/";
                }
            }
        }
        close(BOOKMARK) || die $!;
    }

    return $input;
}

sub format_list {
    my (@list) = @_;
    chomp(@list);

    my @all = ();

    ### find max length for each column
    my $f1_len_max = 0;
    my $f2_len_max = 0;
    for my $line (@list) {
        my @f = split(/\s+/, $line);
        my $name = $f[8];
        if ($line =~ /^.*? +(\d+) +.*? +(\d+) +/) {
            my ($f1, $f2) = ($1, $2);
            my $f1_len = length($f1);
            if ($f1_len > $f1_len_max) {
                $f1_len_max = $f1_len;
            }
            # my $f2_len = length($f2);
            my $f2_len = length(format_size($f2));
            if ($f2_len > $f2_len_max) {
                $f2_len_max = $f2_len;
            }
            if ($line =~ /^d/) {
                push @all, "$line/";
                touch_dir("$TREE_DIR/$URL$name");
            } else {
                push @all, "$line";
                touch_file("$TREE_DIR/$URL$name");
            }
        }
    }

    ### format list (add padding for each column)
    my $result = "";
    for my $line (@all) {
        if ($line =~ /^(.*?) +(\d+)( +.*?) +(\d+)( +.*)/) {
            my $f1_len = length($2);
            # my $f2_len = length($4);
            my $f2_len = length(format_size($4));
            my $f1_len_diff = $f1_len_max - $f1_len;
            my $f2_len_diff = $f2_len_max - $f2_len;
            my $padding1 = " " x $f1_len_diff;
            my $padding2 = " " x $f2_len_diff;
            # $result .= $1 . " " . $padding1  . $2 . $3 . " " . $padding2 . $4 . $5 . "\n";
            $result .= $1 . " " . $padding1  . $2 . $3 . " " . $padding2 . format_size($4) . $5 . "\n";
        }
    }

    return $result;
}

sub format_size {
    my ($byte) = @_;

    if ($byte < 1024) {
        return $byte;
    }

    my $kilo = $byte / 1024;
    if ($kilo < 1024) {
        return(sprintf("%.1f", $kilo) . "K");
    }

    my $mega = $kilo / 1024;
    if ($mega < 1024) {
        return(sprintf("%.1f", $mega) . "M");
    }

    my $giga = $mega / 1024;
    return(sprintf("%.1f", $giga) . "G");
}

### Exec command ###

sub exec_command {
    my ($command) = @_;

    if ($OPT{q}) {
        print "$command\n";
    } else {
        system "$command";
    }
}

### File manipulation ###

sub touch_dir {
    my ($dir) = @_;

    if (! -e "$dir") {
        mkpath("$dir") || warn $!;
    }
}

sub touch_file {
    my ($file) = @_;
    
    open(FILE, ">$file") || warn $!;
    close(FILE) || warn;
}

### For caching ###

sub get_cache_file {
    my ($URL) = @_;

    my $sha256 = sha256_hex($URL);

    my $sub_dir = substr($sha256, 0, 3);
    if (! -e "$CACHE_DIR/$sub_dir") {
        mkpath("$CACHE_DIR/$sub_dir") || die $!;
    }

    return "$CACHE_DIR/$sub_dir/$sha256";
}


sub save_cache {
    my ($cache_file, $result) = @_;

    open(CACHE, ">$cache_file") || die $!;
    print CACHE $result;
    close(CACHE) || die $!;
}

sub retrieve_cache {
    my ($cache_file) = @_;

    if ($OPT{n}) {
        return 0;
    }
    
    if (-e $cache_file and is_recent_file($cache_file)) {
        print_file_content($cache_file);
        return 1;
    } else {
        return 0;
    }
}

sub print_file_content {
    my ($file) = @_;
    
    open(FILE, $file) || die $!;
    my @result = <FILE>;
    close(FILE) || die $!;
    print @result;
}

sub is_recent_file {
    my ($file) = @_;
    
    my @stat = stat $file;
    my $file_time = localtime($stat[9]);
    my $diff_time = str2time($CURRENT_TIME) - str2time($file_time);
    if ($diff_time <= $CACHE_TIME_LIMIT) {
        print "Found results cached at: $file_time\n" if $OPT{v};
        return 1;
    } else {
        return 0;
    }
}
