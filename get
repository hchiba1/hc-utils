#!/usr/bin/perl -w
use strict;
use File::Basename;
use Getopt::Std;
use File::Path;
use Digest::SHA 'sha256_hex';
use HTTP::Date;
my $PROGRAM = basename $0;
my $USAGE=
"Usage: $PROGRAM [OPTIONS] URL
-f: save as file
-o FILE: save as specified file
-p: make parent directory if needed
-q: print command and quit
-d: debug
-n: do not use cache
-v: verbose
-r: recursive
-l: list filename only
";

my $CACHE_TIME_LIMIT = 3600; # one hour
my $CACHE_FILE_SIZE_LIMIT = 100000; # 100K
my $CACHE_DIR = "$ENV{HOME}/.get/cache";
my $TREE_DIR = "$ENV{HOME}/.get/tree";
my $BOOKMARK = "$ENV{HOME}/.get/bookmarks";
my $COMMAND = "curl --max-time 100000 -Lf";

my %OPT;
getopts('fo:pqdnvrl', \%OPT);

!$OPT{v} and $COMMAND .= "sS";

### get URL
if (@ARGV != 1) {
    print STDERR $USAGE;
    exit 1;
}
my ($URL) = @ARGV;
$URL =~ s/^ftp:\/\///;

$URL = search_bookmark($URL);

if ($URL !~ /\//) {
    $URL .= "/";
}

if (! $OPT{n} and ! $OPT{d}) {
    if ($URL !~ /\/$/ && -d "$TREE_DIR/$URL") {
        $URL .= "/";
    }
}

my $CACHE_FILE_PATH = get_cache_file($URL);

my $CURRENT_TIME = localtime;

### get directory contents
if ($URL =~ /\/$/) {
    if ($OPT{r}) {
        system "lr $TREE_DIR/$URL";
        exit;
    }
    
    if ($OPT{q}) {
        print "$COMMAND $URL\n";
    } else {
        my @retrieved = retrieve_cache($CACHE_FILE_PATH);
        if (@retrieved) {
            print format_list(@retrieved);
        } else {
            touch_dir("$TREE_DIR/$URL");
            my @list = `$COMMAND $URL`;
            print format_list(@list);
            save_cache($CACHE_FILE_PATH, join("", @list));
        }
    }
    exit;
}

### get file contents
if ($OPT{p}) {
    if ($URL =~ /^(.+)\/.+$/) {
        my $directory = $1;
        if (-f $directory) {
            rmtree($directory);
        }
        if (! -e $directory) {
            mkpath($directory) || warn $!;
        }
        chdir($directory) || die "$directory: $!";
    }
    exec_command("$COMMAND -OR $URL");
} elsif ($OPT{f}) {
    exec_command("$COMMAND -OR $URL");
} elsif ($OPT{o}) {
    exec_command("$COMMAND -o $OPT{o} $URL");
} else {
    if ($OPT{q}) {
        print "$COMMAND $URL\n";
    } else {
        my @retrieved = retrieve_cache($CACHE_FILE_PATH);
        if (@retrieved) {
            print @retrieved;
        } else {
            my @result = `$COMMAND $URL`;
            my $result = join("", @result);
            print $result;
            my $size = length($result);
            if ($size <= $CACHE_FILE_SIZE_LIMIT) {
                save_cache($CACHE_FILE_PATH, $result);
            }
        }
    }
}

################################################################################
### Functions ##################################################################
################################################################################

sub search_bookmark {
    my ($input) = @_;

    my ($prefix, $suffix);
    if ($input =~ /^([\w\.]+)$/) {
        $prefix = "$1";
        $suffix = "";
    } elsif ($input =~ /^([\w\.]+)(\/.*)/) {
        ($prefix, $suffix) = ($1, $2);
    } else {
        return $input;
    }
    
    if (-f $BOOKMARK) {
        open(BOOKMARK, $BOOKMARK) || die $!;
        while (<BOOKMARK>) {
            if (/^$prefix\s+(\S+)/) {
                my $found = $1;
                if ($suffix) {
                    return "$found$suffix";
                } else {
                    return "$found/";
                }
            }
        }
        close(BOOKMARK) || die $!;
    }

    return $input;
}

sub format_list {
    my (@list) = @_;

    if ($OPT{d}) {
        print @list;
        return;
    }

    if ($OPT{l}) {
        my $result = "";
        for my $line (@list) {
            my @f = split(/\s+/, $line);
            my $name = $f[8];
            $result .= $name . "\n";
        }
        return $result;
    }

    chomp(@list);

    my @all = ();
    my @upper_file = ();
    my @upper_dir = ();
    my @lower_dir = ();
    my @lower_file = ();
    my @others = ();

    ### find max length for each column
    my $f1_len_max = 0;
    my $f2_len_max = 0;
    for my $line (@list) {
        my @f = split(/\s+/, $line);
        my $name = $f[8];
        if ($line =~ /^.*? +(\d+) +\S+ +\S+ +(\d+) +.*/) {
            my ($f1, $f2) = ($1, $2);
            my $f1_len = length($f1);
            if ($f1_len > $f1_len_max) {
                $f1_len_max = $f1_len;
            }
            my $f2_len = length(format_size($f2));
            if ($f2_len > $f2_len_max) {
                $f2_len_max = $f2_len;
            }
            if ($line =~ /^d/) {
                push @all, "$line/";
                push_upper_or_lower("$line/", $name, \@upper_dir, \@lower_dir, \@others);
                touch_dir("$TREE_DIR/$URL$name");
            } elsif ($line =~ /^l/ and $line =~ /\/$/) {
                push @all, "$line";
                push_upper_or_lower("$line", $name, \@upper_dir, \@lower_dir, \@others);
                touch_dir("$TREE_DIR/$URL$name");
            } else {
                push @all, "$line";
                push_upper_or_lower("$line", $name, \@upper_file, \@lower_file, \@others);
                touch_file("$TREE_DIR/$URL$name");
            }
        }
    }

    ### format list (add padding for each column)
    my $result = "";
    # for my $line (@all) {
    for my $line (@upper_file, @upper_dir, @lower_dir, @others, @lower_file) {
        if ($line =~ /^(.*?) +(\d+)( +\S+ +\S+) +(\d+)( +.*)/) {
            my $perm = $1;
            my $num = $2;
            my $user_group = $3;
            my $size = $4;
            my $name = $5;
            my $f1_len = length($num);
            my $f2_len = length(format_size($size));
            my $f1_len_diff = $f1_len_max - $f1_len;
            my $f2_len_diff = $f2_len_max - $f2_len;
            my $padding1 = " " x $f1_len_diff;
            my $padding2 = " " x $f2_len_diff;
            $result .= $perm . " " . $padding1  . $num . $user_group . " " . $padding2 . format_size($size) . $name . "\n";
        }
    }

    return $result;
}

sub push_upper_or_lower {
    my ($line, $name, $a_upper, $a_lower, $a_others) = @_;

    if ($name =~ /^[A-Z][A-Z]/) {
        push @{$a_upper}, $line;
    } elsif ($name =~ /^[a-z]/) {
        push @{$a_lower}, $line;
    } else {
        push @{$a_others}, $line;
    }
}

sub format_size {
    my ($byte) = @_;

    if ($byte < 1024) {
        return $byte;
    }

    my $kilo = $byte / 1024;
    if ($kilo < 1024) {
        return(sprintf("%.1f", $kilo) . "K");
    }

    my $mega = $kilo / 1024;
    if ($mega < 1024) {
        return(sprintf("%.1f", $mega) . "M");
    }

    my $giga = $mega / 1024;
    return(sprintf("%.1f", $giga) . "G");
}

### Exec command ###

sub exec_command {
    my ($command) = @_;

    if ($OPT{q}) {
        print "$command\n";
    } else {
        system "$command";
    }
}

### File manipulation ###

sub touch_dir {
    my ($dir) = @_;

    my $path = $dir;
    $path =~ s/\/$//;
    if (-e $path) {
        rmtree($path);
    }
    
    if (! -e "$dir") {
        mkpath("$dir") || warn $!;
    }
}

sub touch_file {
    my ($file) = @_;

    if (-d $file) {
        return;
    }
    
    open(FILE, ">$file") || warn "$file: $!";
    close(FILE) || warn $!;
}

### For caching ###

sub get_cache_file {
    my ($URL) = @_;

    my $sha256 = sha256_hex($URL);

    my $sub_dir = substr($sha256, 0, 3);
    if (! -e "$CACHE_DIR/$sub_dir") {
        mkpath("$CACHE_DIR/$sub_dir") || die $!;
    }

    return "$CACHE_DIR/$sub_dir/$sha256";
}


sub save_cache {
    my ($cache_file, $result) = @_;

    open(CACHE, ">$cache_file") || die $!;
    print CACHE $result;
    close(CACHE) || die $!;
}

sub retrieve_cache {
    my ($cache_file) = @_;

    if ($OPT{n}) {
        return;
    }
    
    if (-e $cache_file and is_recent_file($cache_file)) {
        open(CACHE_FILE, $cache_file) || die $!;
        my @result = <CACHE_FILE>;
        close(CACHE_FILE) || die $!;
        return @result;
    }

    return;
}

sub is_recent_file {
    my ($file) = @_;
    
    my @stat = stat $file;
    my $file_time = localtime($stat[9]);
    my $diff_time = str2time($CURRENT_TIME) - str2time($file_time);
    if ($diff_time <= $CACHE_TIME_LIMIT) {
        print "Found results cached at: $file_time\n" if $OPT{v};
        return 1;
    } else {
        return 0;
    }
}
